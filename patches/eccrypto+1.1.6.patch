diff --git a/node_modules/eccrypto/build/config.gypi b/node_modules/eccrypto/build/config.gypi
index ee9335d..a9275b5 100644
--- a/node_modules/eccrypto/build/config.gypi
+++ b/node_modules/eccrypto/build/config.gypi
@@ -405,30 +405,21 @@
     "standalone_static_library": 1,
     "version_git_tag": "true",
     "init_author_url": "http://www.mothic.com/",
-    "metrics_registry": "https://registry.npmjs.org/",
     "init_license": "MIT",
-    "global_prefix": "/Users/admin/.nvm/versions/node/v18.16.0",
     "init_author_email": "tim@mothic.com",
     "registry": "https://registry.yarnpkg.com",
-    "local_prefix": "/Users/admin/Documents/Development/block/web5wallet",
-    "globalconfig": "/Users/admin/.nvm/versions/node/v18.16.0/etc/npmrc",
-    "userconfig": "/Users/admin/.npmrc",
-    "init_module": "/Users/admin/.npm-init.js",
     "version_commit_hooks": "true",
     "bin_links": "true",
-    "node_gyp": "/Users/admin/.nvm/versions/node/v18.16.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js",
     "strict_ssl": "true",
     "save_prefix": "^",
-    "version_git_message": "v%s",
     "save_exact": "true",
-    "cache": "/Users/admin/.npm",
+    "version_git_message": "v%s",
+    "user_agent": "yarn/1.22.19 npm/? node/v18.16.0 darwin arm64",
     "ignore_scripts": "",
     "version_git_sign": "",
-    "user_agent": "yarn/1.22.19 npm/? node/v18.16.0 darwin arm64",
     "ignore_optional": "",
     "init_version": "1.0.0",
     "init_author_name": "Timothy Shamilov",
-    "version_tag_prefix": "v",
-    "prefix": "/Users/admin/.nvm/versions/node/v18.16.0"
+    "version_tag_prefix": "v"
   }
 }
diff --git a/node_modules/eccrypto/index.js b/node_modules/eccrypto/index.js
index a63218b..0936a8d 100644
--- a/node_modules/eccrypto/index.js
+++ b/node_modules/eccrypto/index.js
@@ -9,33 +9,21 @@ const EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48
 const ZERO32 = Buffer.alloc(32, 0);
 
 var promise = typeof Promise === "undefined" ?
-              require("es6-promise").Promise :
-              Promise;
+  require("es6-promise").Promise :
+  Promise;
 var crypto = require("crypto");
-// try to use secp256k1, fallback to browser implementation
-try {
-  var secp256k1 = require("secp256k1");
-  var ecdh = require("./build/Release/ecdh");
-} catch (e) {
-  if (process.env.ECCRYPTO_NO_FALLBACK) {
-    throw e;
-  } else {
-    console.info('secp256k1 unavailable, reverting to browser version');
-    return (module.exports = require("./browser"));
-  }
-}
+var secp256k1 = require("secp256k1");
 
-function isScalar (x) {
+function isScalar(x) {
   return Buffer.isBuffer(x) && x.length === 32;
 }
 
 function isValidPrivateKey(privateKey) {
-  if (!isScalar(privateKey))
-  {
+  if (!isScalar(privateKey)) {
     return false;
   }
   return privateKey.compare(ZERO32) > 0 && // > 0
-  privateKey.compare(EC_GROUP_ORDER) < 0; // < G
+    privateKey.compare(EC_GROUP_ORDER) < 0; // < G
 }
 
 function assert(condition, message) {
@@ -78,7 +66,7 @@ function equalConstTime(b1, b2) {
   return res === 0;
 }
 
-function pad32(msg){
+function pad32(msg) {
   var buf;
   if (msg.length < 32) {
     buf = Buffer.alloc(32);
@@ -95,7 +83,7 @@ function pad32(msg){
  * @return {Buffer} A 32-byte private key.
  * @function
  */
-exports.generatePrivate = function() {
+exports.generatePrivate = function () {
   var privateKey = crypto.randomBytes(32);
   while (!isValidPrivateKey(privateKey)) {
     privateKey = crypto.randomBytes(32);
@@ -109,7 +97,7 @@ exports.generatePrivate = function() {
  * @return {Buffer} A 65-byte public key.
  * @function
  */
-var getPublic = exports.getPublic = function(privateKey) {
+var getPublic = exports.getPublic = function (privateKey) {
   assert(privateKey.length === 32, "Bad private key");
   assert(isValidPrivateKey(privateKey), "Bad private key");
   // See https://github.com/wanderer/secp256k1-node/issues/46
@@ -120,7 +108,7 @@ var getPublic = exports.getPublic = function(privateKey) {
 /**
  * Get compressed version of public key.
  */
-var getPublicCompressed = exports.getPublicCompressed = function(privateKey) { // jshint ignore:line
+var getPublicCompressed = exports.getPublicCompressed = function (privateKey) { // jshint ignore:line
   assert(privateKey.length === 32, "Bad private key");
   assert(isValidPrivateKey(privateKey), "Bad private key");
   // See https://github.com/wanderer/secp256k1-node/issues/46
@@ -134,8 +122,8 @@ var getPublicCompressed = exports.getPublicCompressed = function(privateKey) { /
  * @return {Promise.<Buffer>} A promise that resolves with the
  * signature and rejects on bad key or message.
  */
-exports.sign = function(privateKey, msg) {
-  return new promise(function(resolve) {
+exports.sign = function (privateKey, msg) {
+  return new promise(function (resolve) {
     assert(privateKey.length === 32, "Bad private key");
     assert(isValidPrivateKey(privateKey), "Bad private key");
     assert(msg.length > 0, "Message should not be empty");
@@ -154,16 +142,16 @@ exports.sign = function(privateKey, msg) {
  * @return {Promise.<null>} A promise that resolves on correct signature
  * and rejects on bad key or signature.
  */
-exports.verify = function(publicKey, msg, sig) {
-  return new promise(function(resolve, reject) {
+exports.verify = function (publicKey, msg, sig) {
+  return new promise(function (resolve, reject) {
     assert(msg.length > 0, "Message should not be empty");
     assert(msg.length <= 32, "Message is too long");
     msg = pad32(msg);
     sig = secp256k1.signatureImport(sig);
     if (secp256k1.verify(msg, sig, publicKey)) {
-     resolve(null);
+      resolve(null);
     } else {
-     reject(new Error("Bad signature"));
+      reject(new Error("Bad signature"));
     }
   });
 };
@@ -175,8 +163,8 @@ exports.verify = function(publicKey, msg, sig) {
  * @return {Promise.<Buffer>} A promise that resolves with the derived
  * shared secret (Px, 32 bytes) and rejects on bad key.
  */
-var derive = exports.derive = function(privateKeyA, publicKeyB) {
-  return new promise(function(resolve) {
+var derive = exports.derive = function (privateKeyA, publicKeyB) {
+  return new promise(function (resolve) {
     assert(privateKeyA.length === 32, "Bad private key");
     assert(isValidPrivateKey(privateKeyA), "Bad private key");
     resolve(ecdh.derive(privateKeyA, publicKeyB));
@@ -202,20 +190,19 @@ var derive = exports.derive = function(privateKeyA, publicKeyB) {
  * @return {Promise.<Ecies>} - A promise that resolves with the ECIES
  * structure on successful encryption and rejects on failure.
  */
-exports.encrypt = function(publicKeyTo, msg, opts) {
+exports.encrypt = function (publicKeyTo, msg, opts) {
   opts = opts || {};
   // Tmp variable to save context from flat promises;
   var ephemPublicKey;
-  return new promise(function(resolve) {
+  return new promise(function (resolve) {
     var ephemPrivateKey = opts.ephemPrivateKey || crypto.randomBytes(32);
     // There is a very unlikely possibility that it is not a valid key
-    while(!isValidPrivateKey(ephemPrivateKey))
-    {
+    while (!isValidPrivateKey(ephemPrivateKey)) {
       ephemPrivateKey = opts.ephemPrivateKey || crypto.randomBytes(32);
     }
     ephemPublicKey = getPublic(ephemPrivateKey);
     resolve(derive(ephemPrivateKey, publicKeyTo));
-  }).then(function(Px) {
+  }).then(function (Px) {
     var hash = sha512(Px);
     var iv = opts.iv || crypto.randomBytes(16);
     var encryptionKey = hash.slice(0, 32);
@@ -240,8 +227,8 @@ exports.encrypt = function(publicKeyTo, msg, opts) {
  * @return {Promise.<Buffer>} - A promise that resolves with the
  * plaintext on successful decryption and rejects on failure.
  */
-exports.decrypt = function(privateKey, opts) {
-  return derive(privateKey, opts.ephemPublicKey).then(function(Px) {
+exports.decrypt = function (privateKey, opts) {
+  return derive(privateKey, opts.ephemPublicKey).then(function (Px) {
     assert(privateKey.length === 32, "Bad private key");
     assert(isValidPrivateKey(privateKey), "Bad private key");
     var hash = sha512(Px);
